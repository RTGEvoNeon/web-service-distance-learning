<html>
<title>Система дистанционного обучения кафедры </title>
<head bodycolor="000011">
 <link rel="stylesheet" type="text/css" href="../../css/style.css">
 <link rel="stylesheet" type="text/css" href="../../css/abc.css">
        <body BACKGROUND="../../image/background.PNG">
		<br><br>
		<?php
include "../../common/verch.php";
                                   
?>
<a name="33333"></a>
<h1 style="margin-bottom: 10px; color: #445C4C">Лекции по теме: JavaScript<h1>
<table align="center" cellspacing="0" cellpadding="0" border="0">
	<tr>
		<td colspan="2" align="center">
			<ul class="tab">
			<li><a href="java1.php"><span>Лекция № 1</span></a></li>
			<li><a href="java2.php"><span>Лекция № 2</span></a></li>
			<li><a href="java3.php"><span>Лекция № 3</span></a></li>
			<li><a href="java4.php"><span>Лекция № 4</span></a></li>
		</td>
	</tr>
</table>


<table align="justify" width="900" cellspacing="2" cellpadding="2" border="0" bgcolor="white">
<tr>
<td colspan="2" align="center"><br>

<strong><h2>Лекция № 3</h2> </strong><br><br><hr><br><br>


<p> <div align="left" align="justify">&nbsp;&nbsp;&nbsp;&nbsp;

<center>
<p><a class="a1" href="#1">Создание функций</a></p><br>
<p><a class="a1" href="#2">Стандартные функции</a></p><br>
<p><a class="a1" href="#3">Параметры функций. Области видимости. Значение и ссылка</a></p>
<br>
</center>
<a name="1"></a>
<h4>Создание функций.</h4>
<p>Те скрипты, которые мы рассматривали до этого времени, были очень небольшими, можно сказать – на один экран редактора. И весь код был виден одновременно. Но если представить, что скрипт занимает не пятнадцать строчек, а все полторы тысячи – как в нем разобраться?  </p>

<p>Тот код, который мы писали, использовался сразу, и в одном единственном месте. Но если представить, что один и тот же код должен исполняться в сорока разных местах, да еще и только тогда, когда наступит нужное время... </p>
<p>Та последовательность команд, которая выполняла необходимые нам действия, до сих пор не вызывала затруднений в понимании. Но если эта последовательность будет слишком сложна для того чтобы прочесть ее за один раз... </p>
<p>Собственно, все эти проблемы решаются, и уже достаточно давно, при помощи функций. </p>
<p>Что же такое функция? Если не вдаваться в подробности (а на первых порах эти подробности будут только мешать) функция представляет из себя некоторый блок кода, которому дали имя. Например, вот типичное объявление функции: </p>

<pre>
function diff(a,b) { 
	if (a&gt;b) {
		return a – b;
	} else {
		return b – a;
	}
}
</pre>

<p>В этом коде объявляется функция под именем <span class="T1">diff</span> (именно так к ней можно будет обращаться в тексте программы). Эта функция ожидает два параметра – <span class="T1">a</span> и <span class="T1">b</span>. </p>

<p>При вызове любые значения, которые были переданы функции, запишутся в переменные <span class="T1">a</span> и <span class="T1">b</span> внутри тела функции (кода между фигурными скобками), и к ним можно будет обращаться по этим именам.</p>
<p>Оператор <span class="T1">return</span> (да, это еще один оператор, который можно применять только внутри тела функции) завершает выполнение блока кода и возвращает значение, если оно есть.</p>
<p>Эта функция может быть вызвана вот так: </p>

<pre>

var c = diff(4, 7);
var d = diff(c, 12);
</pre>

<p>Как вы видите, функция, которая была объявлена выше, вызывается с двумя параметрами, и возвращает значение, которое можно записать в переменную или использовать (или не использовать) любым другим образом. </p>
<p>При вызове функции нужно помнить, что эта функция должна быть объявлена или в текущем блоке кода, или в одном из предыдущих, иначе браузер выдаст ошибку. </p>
<p>В приведенном примере один и тот же код был применен два раза, причем действия, которые он выполнил, зависели от того, что именно было передано в функцию. </p>
<p>Думаю, вас не удивит тот факт, что внутри одной функции можно вызывать другую функцию (если вызываемая функция уже объявлена). </p>
<p>Например: </p>

<pre>
function inner(a) { 
	return a + 2;
} 
function outer(x) {
	var intermediate = inner(x);
	intermediate += inner(x*x);
	return intermediate;
}
</pre>

<p>Кстати, таким же образом функция может вызывать сама себя. Такой вызов называется рекурсией.  </p>

<p>Вот, пример простой функции с рекурсией: </p>

<pre>
function countback(num) { 
	if (num &gt; 0) {
		alert(num);
		countback(num-1);
	}
} 
</pre>

<p>В этой функции обязательно присутствует условие, которое определяет, нужно еще раз вызвать эту же функцию, или нет. </p>
<p>В чем-то такие рекурсивные функции похожи на циклы (и большую часть циклов можно переписать в виде рекурсивных функций, и наоборот). </p>

<p>В рекурсивной функции обязательно есть условие и какой-нибудь изменяемый параметр. </p>

<p>Если вы вспомните предыдущую главу, то также вспомните, что функция в JavaScript тоже является типом. И функцию можно записать в переменную. Поначалу это кажется странным, особенно для тех, кто уже сталкивались с языками вроде C, Java или PHP. </p>
<p>Но на самом деле ничего сложного в этом нет. </p>

<p>Например, вот такая запись: </p>
<pre>
function fnc(a) {
	return a + 1;
}

var f = fnc; 
</pre>

<p>создаст функцию <span class="T1">fnc()</span> и запишет ее в переменную <span class="T1">f</span>.</p>

<p>Если быть точным, то запишется не сама функция, а только ссылка на нее, но к этой разнице я вернусь несколько позже. </p>
<p>Итак, при исполнении браузером этого кода будет создана функция. Из записи понятно, что она будет получать один параметр, и будет возвращать значение. </p>
<p>При этом возможен как вызов функции напрямую, при помощи имени <span class="T1">fnc()</span>, так и посредством переменной <span class="T1">f</span>, тоже – просто написав скобки за именем. Вот так : <span class="T1">f()</span></p>
<p>Поскольку функция теперь является значением переменной, то это значение можно записывать в другие переменные и передавать в другие функции.  </p>
<p>Например, такой код будет вполне работоспособным (и, кроме того, этот способ часть используется и приносит неплохие результаты): </p>

<pre>

function compare(a) { 
	return a &gt; 12;
}
var user_func = compare;

function check (arr, fn) {
	var passed = 0;
	for (var i=0; i&lt;arr.length; i++) {
		if (fn(arr[i])) {
			passed++;
		}
	}
	return passed;
}

alert (check([1,5,15,34,2,32,44], user_func)); 
</pre>

<p>Причем, в качестве второго параметра можно передавать сразу функцию, не утруждаясь занесением ее функции в переменную. </p>
<p>Кроме описанного способа создания функций, есть еще два – но они используются не настолько часто, и о них я напишу в одной из следующих глав. </p>
<a name="2"></a>
<h4>Стандартные функции.</h4>
<p>Их, на удивление, не так уж и много. Большая часть полезных функций разнесена по встроенным объектам языка (и браузера). Но все же нашлось несколько таких функций, которые невозможно было отнести к какому-нибудь объекту. </p>
<p>Вот они: </p>

<ul>
<li>
	<p>
		<span class="T1">eval()</span> : позволяет выполнить строку как javascript-код. Это бывает полезно когда код приходит из внешнего источника (например, от сервера) или если он формируется в ходе выполнения скрипта.
	</p>
</li>

<li>
	<p>
		<span class="T1">parseInt()</span>, <span class="T1">parseFloat()</span> : эти функции предназначены для того, чтобы превращать строку в число (с учетом системы счисления). Например, можно свободно работать с двоичными, восьмеричными или (для оригиналов) с пятеричными числами.
	</p>

	<p>Первая работает с целыми числами, вторая – с числами с плавающей точкой. </p>
</li>

<li>
	<p>
		<span class="T1">encodeURI()</span>, <span class="T1">decodeURI()</span>, <span class="T1">encodeURIComponent()</span>, <span class="T1">decodeURIComponent()</span> : Эти функции предназначены для работы с <span class="T1">URI </span>(Uniform Resource Identifier). Этот стандарт требует, чтобы некоторые символы отсутствовали в <span class="T1">URI</span>, и указанные функции для преобразования этих символов. 
	</p>

</li>

<li>
	<p>
		<span class="T1">isNaN()</span> : Бывают случаи, когда числовая операция ни при каких условиях не может вернуть число. Например, при попытке преобразования строки «<span class="T1">hello</span>» с помощью функции <span class="T1">parseIn</span>t. В таком случае используется специальное нечисловое значение (так называемое «не-число», <span class="T1">NaN</span>). Для проверки, является ли аргумент этим не-числом, и используется указанная функция.
	</p>
</li>

<li>
	<p>
		<span class="T1">isFinite()</span> : Очень похожа на предыдущую, но кроме <span class="T1">NaN</span> также проверяет <span class="T1">Infinite</span> (то есть бесконечность).
	</p>
</li>
</ul>

<p>Также, все встроенные объекты языка JavaScript одновременно являются функциями (и наоборот). Вы поймете, почему это так когда узнаете, как именно создаются объекты, кроме описанного мной литерального способа (то есть фигурных скобок). Так что вызовы вида  </p>
<pre>
var a  = String(23);
</pre>
<p>вполне допустимы. </p>

<p>Сейчас вы можете спросить, почему в этом списке нет функции <span class="T1">alert()</span>. </p>
<p>Действительно, хотя мы и использовали эту функцию без предварительного объявления, и не указывали объект к которому она относится, эта функция не является стандартной функцией языка. </p>

<p>Все дело в том, что кроме стандартных функций, без указания объекта могут вызываться функции объекта <span class="T1">window</span>. Вообще, любые глобальные переменные и функции являются переменными и функциями объекта <span class="T1">window</span>.</p>

<p>Например, когда мы вместо того чтобы написать </p>
<pre>
var a = 2; 
</pre>
<p>пишем  </p>
<pre>
a = 2;
</pre>

<p>мы добавляем переменную <span class="T1">a</span> к объекту <span class="T1">window</span>. При этом, следует заметить, есть некоторые тонкости. Использование необъявленной переменной вызовет ошибку, а использование необъявленного свойства объекта просто вернет <span class="T1">undefined</span></p>

<a name="3"></a>
<h4>Параметры функций. Области видимости. Значение и ссылка.</h4>
<p>Когда мы объявляли функцию, мы указывали параметры, которые она будет принимать. Но, кроме этих параметров, внутри функции также могут использоваться глобальные переменные, и создаваться локальные. Да и с параметрами не все так просто, как кажется. </p>

<p>Например, объявляем мы функцию вот так: </p>
<pre>
function x(a,b,c) {  
} 
</pre>

<p>А вызываем так: </p>
<pre>
x(1,2);

</pre>

<p>Как вы думаете, что будет? </p>
<p>Нет, браузер не выдаст ошибку, хотя функция и получила меньше параметров, чем ожидала. </p>
<p>Просто при вызове этой функции параметры <span class="T1">a</span> и <span class="T1">b</span> примут соответственно значения 1 и 2, а вот параметр <span class="T1">c</span> окажется <span class="T1">undefined</span></p>

<p>Также мы могли бы написать и  </p>
<pre>
x(1,2,3,4,5);
</pre>
<p>И даже в этом случае никакой ошибки не будет. Параметры 4 и 5 никуда не исчезнут, а будут находиться в «труднодоступных» местах. </p>
<p>Здесь стоило бы немного больше сказать о том, что функция является объектом. </p>
<p>Так, у любой функции после создания есть свойства и методы (если я еще не говорил, то методом называется свойство, являющееся функцией – запутано, правда?). Например, для объявленной выше функции <span class="T1">x</span> можно вызвать метод <span class="T1">toString()</span>:</p>

<pre>
var a = x.toString();
</pre>

<p>И в результате в переменой a окажется строка «<span class="T1">function x(a,b,c){}</span>»</p>

<p>Кроме этого, внутри тела функции всегда можно использовать объект <span class="T1">arguments</span>, при помощи которого и можно было бы добраться до параметров 4 и 5 при вызове функции с помощью команды</p>
<pre>
x(1,2,3,4,5); 
</pre>

<p>Кроме того, следует сказать о передаче параметров по ссылке. </p>
<p>Например, если мы передаем в функцию число, то оно передается по значению – то есть внутри функции создается копия параметра, и уже с этой копией и происходит вся работа. </p>
<p>Но в случае, если в функцию передается объект (или массив, или даже функция) – все происходит немного иначе. </p>
<p>Дело в том, что даже когда мы просто присваиваем переменной значение объекта, эта переменная хранит не сам объект, а только ссылку на него.  </p>
<p>В результате, после таких команд </p>
<pre>
var a = {'a':1}; 
var b = a; 
</pre>

<p>обе переменные будут указывать на один и тот же объект, и при таком вот действии </p>

<pre>
a.x = 2; 
</pre>
<p>можно будет обращаться к <span class="T1">b.x</span>, и там будет содержаться та же самая двойка.</p>

<p>То же самое происходит и при вызове функции – аргумент будет содержать ссылку на объект. И так же точно любые изменения этого объекта (при обращении к нему через аргумент функции) не исчезнут после завершения функции. </p>

<p>Такое поведение объектов иногда причиняет неудобства программисту – иногда приходится идти на ухищрения, чтобы получить копию объекта, но очень часто это бывает удобно. </p>
<p>Учитывая такую разницу в поведении разных типов, было бы неплохо определять, с каким собственно типом приходится работать. И для этого в языке JavaScript существуют целых два оператора – <span class="T1">typeof</span> и <span class="T1">instanceof</span>.</p>

<p>Первый из них возвращает тип операнда (в виде строки) – например,  </p>
<pre>
typeof {a:1}; 
</pre>
<p>вернет строку «<span class="T1">object</span>»</p>

<p>Второй оператор показывает, является ли первый операнд (объект) экземпляром второго операнда (тоже объекта). Это полезно в том случае, когда нам нужно проверить, является ли переданный объект массивом или, например, датой (то есть это объект – экземпляр встроенного объекта <span class="T1">Array</span> или встроенного объекта <span class="T1">Date</span>). Но об этом операторе, а также о вопросах наследований и объектов я расскажу в соответствующей главе.</p>

<p>А сейчас вернемся к функциям. </p>
<p>Внутри тела функции, кроме пришедших извне операндов, могут объявляться и другие  переменные (при помощи оператора <span class="T1">var</span>). В этом случае переменная будет локальной – то есть она не будет видна снаружи функции. </p>
<p>Если же мы используем необъявленную внутри функции переменную, то это будет либо глобальная переменная (точнее, внешняя – будет использоваться переменная из той функции, внутри которой объявлена текущая, или из функции, в которой объявлена функция, в которой объявлена текущая функция, и так далее), либо свойство объекта <span class="T1">window</span>.</p>
<p>При этом стоит заметить, что если объявлена локальная переменная, то доступ к глобальной переменной с тем же именем закрывается – все действия переменных будут происходить с локальной переменной. </p>
<p>И, собственно, аргументы функции автоматически становятся локальными переменными. </p>




<br><br><hr><br><br><center>

<br><a class="a1" href="#33333">Наверх</a><br>
<br>
</td>
</tr>
</table>
	                  
        </body>     
  
</html>
